<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_boy1</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>par_pausable</parentName>
  <maskName>spr_playertest</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize Player Variables
name = "Atom";

// Physics Variables
grav = 0.2;
hspd = 0;
hspd_platform = 0;
vspd = 0;
jspd = 6;
mspd = 3;
mvmt = 0;

// Sprite Variables
spr = "boy1"
spr_run = spr_boy1;
spr_jump = spr_boy1_jump;
spr_fall = spr_boy1_fall;
image_speed = 0;
depth = -3;
idle = false;
idle_count = 0;

// Mechanic Variables
total_charge = 0;
global.inventory = ds_list_create();
is_winning = false;
complete = false;
paused = false;
scrn = -1;
attempts = 0;
toggle = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Play Music

// This will play the audio and set its priorty level to be higher than all other sounds
// because the player is persistant, the audio will continue to play.

audio_play_sound(music_AtomPuzzlerTheme, 1, true);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Sprite Operations

/* The player's sprite will turn left and right
depending on whether or not 'mvmt' is -1 or 1.
If the player is on the ground and moving, its 
sprite_index will be set to his running animation
(spr_boy1). If not, the player's sprite will be the 
first frame of his running animation, standing still
(frame 1 of spr_boy1). If the player is not on the ground,
and their 'vspd' is less than 0 (jumping) then the
player's sprite_index is set to 'spr_boy1_jump'.
Otherwise, the player's sprite will be set to the
'spr_boy1_fall' animation. Then, if the sprite_index is 
one less than its image_number, then the image_speed becomes
zero so the fall animation doesn't repeat.
*/


if(mvmt != 0)
{
    image_xscale = mvmt;
}
if(place_meeting(x, y + 1, obj_obstacle))
{
    if(mvmt != 0)
    {
        sprite_index = spr_run;
        image_speed = 0.2;
        idle_count = 0;
        idle = false;
    }
    else
    {
        if(idle)
        {
            sprite_index = spr_idle;
            image_speed = 0.2;
        }
        else
        {
            idle_count++;
            sprite_index = spr_run;
            image_speed = 0;
            image_index = 0;
            if(idle_count == 600)
            {
                idle = true;
            }
        }
    }
}
else
{

    if(vspd &lt;= 0)
    {
        sprite_index = spr_jump;
        image_speed = 0;
    }
    else
    {
        sprite_index = spr_fall;
        if(image_index &lt; image_number - 2)
        {
            image_speed = 0.2;
        }
        else
        {
            image_speed = 0;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Change Character

// Checks Case for Character
switch(spr)
{
   case "boy1":
   {
       spr_run = spr_boy1;
       spr_jump = spr_boy1_jump;
       spr_fall = spr_boy1_fall;
       spr_idle = spr_boy1_idle;
       break;
   }
   case "girl1":
   {
       spr_run = spr_girl1;
       spr_jump = spr_girl1_jump;
       spr_fall = spr_girl1_fall;
       spr_idle = spr_girl1_idle
       break;
   }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Player Inputs and Physics Calculations (Keyboard)

/* 'key_right', 'key_left' and 'key_jump' are all variable 
place holders for the player's inputs. When the player presses
left or right, the 'keyboard_check's for left and right will 
either equal 1 or 0, making 'key_right' always equal 1 or 0 and
'key_left' always equal -1 or 0. 'keyboard_check_pressed' will 
check to see if 'vk_space' was only just pressed.
REMEMBER: these checks happen every frame of the game.
*/

if(toggle == 0)
{
    key_right = keyboard_check(vk_right);
    key_left = -keyboard_check(vk_left);
    key_jump = keyboard_check_pressed(vk_space) || device_mouse_check_button_pressed(0, mb_right);
}

/* If key_jump is true, then the sound effect for jumping will be played.
*/

if (key_jump == true &amp;&amp; vspd == 0) 
{
    audio_play_sound(sfx_jump, 0, false);
}


// Use Player Inputs

/* 'mvmt' will be used as the number to represent whether or not 
the player wants to go left, right or nowhere -1, 0 or 1). 'hspd' 
will be the product of our 'mvmt' and our generic 'mspd' multiplier.
The first 'if' statement provided stops the player from gaining 'vspd' 
if their current 'vspd' is greater than or equal to 10 pixels per 
frame in the downward direction. Otherwise, it will continue to add 
'grav' to 'vspd' to make a new 'vspd' value. The second 'if' statement
ehecks to see if the player is on an 'obj_obstacle' object and sets the
'vspd' to the product of 'key_jump' (0 or 1) and the negative value of 
'jspd'. This will make the player's vspd negative, sending them 
upwards. 
*/

mvmt = key_left + key_right;

//hspd = mvmt * mspd;

if(vspd &lt; 10)
{
    vspd += grav;
}

if(place_meeting(x, y + 1, obj_obstacle))
{
    vspd = key_jump * -jspd;
}

// Pixel Perfect Horizontal Collisions

/* The 'if' statement checks to see if the player is a certain 
distance (x + hspd) away from the nearest 'obj_obstacle' horizontally. 
If they are, it checks to see if they are another distance away from
the 'obj_obstacle' (x + sign(hspd) and if they are, it adds the player's
absolute value of their 'hspd' to their current x-coordinate and makes
that value their new x-coordinate. Then, it sets the new 'hspd' to 0
to set the player's collisions and movement up for the next frame.
It then updates the player's new x-coordinate to their current x-coordinate
plus their 'hspd'. This ensures we get as close to the obstacle as possible,
without going into the obstacle. 
*/

var hspd_final = hspd + hspd_platform;
hspd_platform = 0;
if(place_meeting(x + hspd_final, y, obj_obstacle))
{
    while(!place_meeting(x + sign(hspd_final), y, obj_obstacle))
    {
        x += sign(hspd_final);
    }
    hspd = 0;
    hspd_final = 0;
}
x += hspd_final;

// Pixel Perfect Vertical Collisions

/* The 'if' statement checks to see if the player is a certain 
distance (y + vspd) away from the nearest 'obj_obstacle' vertically. 
If they are, it checks to see if they are another distance away from
the 'obj_obstacle' (y + sign(vspd) and if they are, it adds the player's
absolute value of their 'vspd' to their current y-coordinate and makes
that value their new y-coordinate. Then, it sets the new 'vspd' to 0
to set the player's collisions and movement up for the next frame.
It then updates the player's new y-coordinate to their current y-coordinate
plus their 'vspd'. This ensures we get as close to the obstacle as possible,
without going into the obstacle.
*/

if(place_meeting(x, y + vspd, obj_obstacle))
{
    while(!place_meeting(x, y + sign(vspd), obj_obstacle))
    {
        y += sign(vspd);
    }
    vspd = 0;
}
y += vspd;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Prevents player from running forever and halts sprite animation
/*
    Whenever the player holds down right/left key and presses up near door, 
    player keeps running right and this fixes it
*/

if(toggle != 0)
{
    mvmt = 0;
    hspd = 0;
}

hspd = mvmt * mspd;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///On Key Press X, drops previous atom picked

//  Notes: Deleting from ds_list does not change list size.
//  TODO: Remove last item from list, clear list, put leftover items into list again, this will require two lists maybe

if(keyboard_check_pressed(ord("X")))
{
    if(ds_list_size(global.inventory) &gt; 0) 
    {
        scr_drop_atom(global.inventory);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_door">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
scr_sort_list(global.inventory);
scr_sort_list(global.room_list);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Door Collision Event for Room Type Normal
/*
Checks for both lists: room and player's inventory.
Checks sizes of both lists, then checks for the content within list.
If the content within the player's inventory matches the room's list, then give correct feedback and move to next room and vice versa.
*/

if(keyboard_check_released(vk_up) &amp;&amp; instance_nearest(x, y, obj_door).doorExit &amp;&amp; global.room_type == 1) 
{

    scr_debug_list();
    
    scr_sort_list(global.inventory);
    scr_sort_list(global.room_list);

    //Set variables for size of lists
    room_array_size = ds_list_size(global.room_list);
    inventory_size = ds_list_size(global.inventory);
    
    //Boolean set to false by default
    inventory_check = false;
    
    //Compare size of both lists
    if(room_array_size == inventory_size) 
    {
        //Compare and match list by index, if content doesn't match then break loop
        for(i = 0; i &lt; inventory_size; i++) 
        {
            if(ds_list_find_value(global.inventory, i) = ds_list_find_value(global.room_list, i))
            {
                inventory_check = true;
            }
            else
            {
                inventory_check = false;
                break;
            }            
        }
        
        //Win
        if(inventory_check)
        {
            is_winning = true;
            instance_create(0, 0, obj_win);
            //show_debug_message("obj_player: Event Collide: obj_door:  instance_create: obj_win");
            global.totalPoints = global.points - round(global.roomPoints) + global.totalPoints;
            obj_timer.stop = true;
            with(instance_nearest(x, y, obj_door)) doorExit = false;
            toggle = -1;
        }
        
        //Lose
        else
        {   
            is_winning = false;
            instance_create(0, 0, obj_gameover);
            //show_debug_message("obj_player: Event Collide: obj_door: On Lose: instance_create: obj_gameover");
            obj_timer.stop = true;
            toggle = -1;
            attempts++;
        }
    }
    
    //Size does not match therefore lose
    else
    {
        is_winning = false;
        instance_create(0, 0, obj_gameover);
        //show_debug_message("obj_player: Event Collide: obj_door: Incorrect List Size: instance_create: obj_gameover");
        obj_timer.stop = true;
        toggle = -1;
        attempts++;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Door Collision Event for Room Type Lab

/* 
The reason why there is duplicate code for separate room types is that Lab rooms do 
not have a timer object and Normal rooms do. The game throws an 'object that does not exist' 
error if timer is stopped in Lab room, therefore the duplicated code for both room types.
*/ 

if(keyboard_check_released(vk_up) &amp;&amp; instance_nearest(x, y, obj_door).doorExit &amp;&amp; global.room_type == -1) 
{

    scr_debug_list();
    
    scr_sort_list(global.inventory);
    scr_sort_list(global.room_list);

    //Set variables for size of lists
    room_array_size = ds_list_size(global.room_list);
    inventory_size = ds_list_size(global.inventory);
    
    //Boolean set to false by default
    inventory_check = false;
    
    //Compare size of both lists
    if(room_array_size == inventory_size) 
    {
        //Compare and match list by index, if content doesn't match then break loop
        for(i = 0; i &lt; inventory_size; i++) 
        {
            if(ds_list_find_value(global.inventory, i) = ds_list_find_value(global.room_list, i))
            {
                inventory_check = true;
            }
            else
            {
                inventory_check = false;
                break;
            }            
        }
        
        //Win
        if(inventory_check)
        {
            is_winning = true;
            instance_create(0, 0, obj_win);
            global.totalPoints = global.totalPoints + 100;
            with(instance_nearest(x, y, obj_door)) doorExit = false;
            toggle = -1;
        }
        
        //Lose
        else
        {   
            is_winning = false;
            instance_create(0, 0, obj_gameover);
            //global.points -= 100;
            global.totalPoints = global.totalPoints - 100;
            toggle = -1;
        }
    }
    
    //Size does not match therefore lose
    else 
    {
        is_winning = false;
        instance_create(0, 0, obj_gameover);
        //global.points -= 100;
        global.totalPoints = global.totalPoints - 100;
        toggle = -1;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Debug test code for room and output the debug messages.

/*if (room_exists(room_next(room)) &amp;&amp; keyboard_check(vk_up))
{
    if(debug_mode)
    {
        room_goto_next();
        x = 
        show_debug_message("You have sucessfully moved to the next room");
        show_message("You have sucessfully moved to the next room");
    }
}

else if (!room_exists(room_next(room)) &amp;&amp; keyboard_check(vk_up) &amp;&amp; debug_mode)
{
    show_debug_message("Next room does not exist");
    show_message("Next room does not exist");
}

else
{

}
*/

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_atom1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Adds Values from Received Atom

// On Key Press Z, picks up atom

if(keyboard_check_pressed(ord("Z")))
{
    total_charge += instance_nearest(x, y, obj_atom1).charge;
    ds_list_add(global.inventory, instance_nearest(x, y, obj_atom1).symbol);
    show_debug_message("Add to Inventory: " + string(instance_nearest(x, y, obj_atom1).symbol));
    complete = false;
    
    for(i = 0; i &lt; ds_list_size(global.room_list); i++)
    {
        if(instance_nearest(x, y, obj_atom1).symbol == ds_list_find_value(global.room_list, i))
        {
            global.points += 200;
            complete = true;
        }
        if(complete)
        {
            break;
        }
    }

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="32">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Press Spacebar after winning to continue

if(is_winning)
{
    ds_list_clear(global.inventory);
    global.points = 0;
    global.roomPoints = 0;
    toggle = 0;
    is_winning = false;
    
    //Check if the current room is the last room
    if(room = room_last)
    {
        //stores the player name 
        name = get_string("Please enter your name:","");
        
        //puts score in to the score board
        highscore_add(name, global.totalPoints);
        
        //puts the player back to the main room
        room_goto(rm_scoreBoard);
        x = 32;
        y = 320;
    }
    else 
    {
        room_goto_next();
        x = 32;
        y = 320;
    }
    
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Wrap the Room for Player

move_wrap(true, false, rm1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw Self

draw_self();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="82">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Restart Room
/*
Checks if player has both collected the right atoms and checks if the inventory size is not 0
*/

if(!obj_player.is_winning || (ds_list_size(global.inventory) != 0) &amp;&amp; global.room_type == 1)
{   
    obj_player.x = 32;
    obj_player.y = 415;
    toggle = 0;
    global.points = 0;
    ds_list_clear(global.inventory);
    room_restart();
    obj_player.attempts = 0;
}

if(!obj_player.is_winning || (ds_list_size(global.inventory) != 0) &amp;&amp; global.room_type == -1)
{
    obj_player.x = 32;
    obj_player.y = 300;
    toggle = 0;
    global.points = 0;
    ds_list_clear(global.inventory);
    room_restart();
    obj_player.attempts = 0;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
