<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_boy1</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize Player Variables

/*'grav' is gravity, 'hspd' is horizontal speed container,
'vspd' is vertical speed container, 'jspd' is the jump speed
whenever jump is used, and 'mspd' is the horizontal movement 
speed to be added or subtracted.*/

inventory = ds_list_create();
grav = 0.2;
hspd = 0;
vspd = 0;
jspd = 6;
mspd = 3;
spr = "boy1"
spr_run = spr_boy1;
spr_jump = spr_boy1_jump;
spr_fall = spr_boy1_fall;
total_charge = 0;
total_symbol = "";
image_speed = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Player Inputs

/* 'key_right', 'key_left' and 'key_jump' are all variable 
place holders for the player's inputs. When the player presses
left or right, the 'keyboard_check's for left and right will 
either equal 1 or 0, making 'key_right' always equal 1 or 0 and
'key_left' always equal -1 or 0. 'keyboard_check_pressed' will 
check to see if 'vk_space' was only just pressed.
REMEMBER: these checks happen every frame of the game.
*/

key_right = keyboard_check(vk_right);
key_left = -keyboard_check(vk_left);
key_jump = keyboard_check_pressed(vk_space);

// Use Player Inputs

/* 'mvmt' will be used as the number to represent whether or not 
the player wants to go left, right or nowhere -1, 0 or 1). 'hspd' 
will be the product of our 'mvmt' and our generic 'mspd' multiplier.
The first 'if' statement provided stops the player from gaining 'vspd' 
if their current 'vspd' is greater than or equal to 10 pixels per 
frame in the downward direction. Otherwise, it will continue to add 
'grav' to 'vspd' to make a new 'vspd' value. The second 'if' statement
ehecks to see if the player is on an 'obj_obstacle' object and sets the
'vspd' to the product of 'key_jump' (0 or 1) and the negative value of 
'jspd'. This will make the player's vspd negative, sending them 
upwards. 
*/

mvmt = key_left + key_right;
hspd = mvmt * mspd;
if(vspd &lt; 10)
{
    vspd += grav;
}
if(place_meeting(x, y + 1, obj_obstacle))
{
    vspd = key_jump * -jspd;
}

// Pixel Perfect Horizontal Collisions

/* The 'if' statement checks to see if the player is a certain 
distance (x + hspd) away from the nearest 'obj_obstacle' horizontally. 
If they are, it checks to see if they are another distance away from
the 'obj_obstacle' (x + sign(hspd) and if they are, it adds the player's
absolute value of their 'hspd' to their current x-coordinate and makes
that value their new x-coordinate. Then, it sets the new 'hspd' to 0
to set the player's collisions and movement up for the next frame.
It then updates the player's new x-coordinate to their current x-coordinate
plus their 'hspd'. This ensures we get as close to the obstacle as possible,
without going into the obstacle. 
*/

if(place_meeting(x + hspd, y, obj_obstacle))
{
    while(!place_meeting(x + sign(hspd), y, obj_obstacle))
    {
        x += sign(hspd);
    }
    hspd = 0;
}
x += hspd;


// Pixel Perfect Vertical Collisions

/* The 'if' statement checks to see if the player is a certain 
distance (y + vspd) away from the nearest 'obj_obstacle' vertically. 
If they are, it checks to see if they are another distance away from
the 'obj_obstacle' (y + sign(vspd) and if they are, it adds the player's
absolute value of their 'vspd' to their current y-coordinate and makes
that value their new y-coordinate. Then, it sets the new 'vspd' to 0
to set the player's collisions and movement up for the next frame.
It then updates the player's new y-coordinate to their current y-coordinate
plus their 'vspd'. This ensures we get as close to the obstacle as possible,
without going into the obstacle.
*/

if(place_meeting(x, y + vspd, obj_obstacle))
{
    while(!place_meeting(x, y + sign(vspd), obj_obstacle))
    {
        y += sign(vspd);
    }
    vspd = 0;
}
y += vspd;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Change Character
/*
if(spr = "boy1")
{
        spr_run = spr_boy1;
        spr_jump = spr_boy1_jump;
        spr_fall = spr_boy1_fall;
    }
    else if(spr = "girl1")
    {
        spr_run = spr_girl1;
        spr_jump = spr_girl1_jump;
        spr_fall = spr_girl1_fall;
    }
*/
switch(spr)
{
    case "boy1":
    {
        spr_run = spr_boy1;
        spr_jump = spr_boy1_jump;
        spr_fall = spr_boy1_fall;
        break;
    }
    case "girl1":
    {
        spr_run = spr_girl1;
        spr_jump = spr_girl1_jump;
        spr_fall = spr_girl1_fall;
        break;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Sprite Operations

/* The player's sprite will turn left and right
depending on whether or not 'mvmt' is -1 or 1.
If the player is on the ground and moving, its 
sprite_index will be set to his running animation
(spr_boy1). If not, the player's sprite will be the 
first frame of his running animation, standing still
(frame 1 of spr_boy1). If the player is not on the ground,
and their 'vspd' is less than 0 (jumping) then the
player's sprite_index is set to 'spr_boy1_jump'.
Otherwise, the player's sprite will be set to the
'spr_boy1_fall' animation. Then, if the sprite_index is 
one less than its image_number, then the image_speed becomes
zero so the fall animation doesn't repeat.
*/

if(mvmt != 0)
{
    image_xscale = mvmt;
}

if(place_meeting(x, y + 1, obj_obstacle))
{
    if(mvmt != 0)
    {
        sprite_index = spr_run;
        image_speed = 0.2;
    }
    else
    {
        sprite_index = spr_run;
        image_speed = 0;
        image_index = 0;
    }
}
else
{
    if(vspd &lt; 0)
    {
        sprite_index = spr_jump;
        image_speed = 0;
    }
    else
    {
        sprite_index = spr_fall;
        image_speed = 0.2;
        if(image_index = image_number - 1)
        {
            image_speed = 0;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_door">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Interact with the Door

if(keyboard_check(vk_down))
{
    if(total_charge = global.correct_charge &amp;&amp; ord(total_symbol) = ord(global.correct_symbol))
    {
        global.message[0] = global.win_message;
        obj_timer.stop = true;
    }
    else
    {
        global.message[0] = global.lose_message;
        obj_timer.stop = true;
    }
}

//Resets inventory and player's position then goes to next room if available.
if (room_exists(room_next(room)) &amp;&amp; keyboard_check( vk_up )) 
{
    ds_list_clear(inventory);
    room_goto_next();
    x = 32;
    y = 320;
}

//check if both list have same array size
//check both index in order for same values
if(keyboard_check(vk_f1)) 
{
    room_array_size = ds_list_size(global.room_list);
    inventory_size = ds_list_size(inventory);
    
    inventoryCheck = false;
    
    if(room_array_size == inventory_size) 
    {
        for(i = 0; i &lt; inventory_size; i++) 
        {
            if(ds_list_find_value(inventory, i) == ds_list_find_value(global.room_list, i))
            {
                inventoryCheck = true;
            }
            else
            {
                inventoryCheck = false;
                break;
            }            
        }
        
        if(inventoryCheck == true)
        {
            global.message[0] = global.win_message;
            obj_timer.stop = true;
        }
        else
        {
            global.message[0] = global.lose_message;
            obj_timer.stop = true;
        }
    }
    else 
    {
        global.message[0] = "Array Size does not match";
        obj_timer.stop = true;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_atom_test1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Adds Values from Received Atom

total_charge += instance_nearest(x, y, obj_atom_test1).charge;
total_symbol += instance_nearest(x, y, obj_atom_test1).symbol;

ds_list_add(inventory, instance_nearest(x, y, obj_atom_test1).symbol);
ds_list_sort(inventory, true);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Wrap the Room for Player

move_wrap(true, false, rm1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw Self and Charge
draw_self();

draw_set_color(c_blue);

// TEMPORARY
//draw_text(550, 60, total_charge);
//draw_text(550, 100, total_symbol);
// TEMPORARY


//Temporary, prints out list size for testing purposes
draw_text(450, 100, "inventory size: " + string(ds_list_size(inventory)));

//Prints array of values in inventory list
for(i = 0; i &lt; ds_list_size(inventory); i++) {
    draw_text(600, 160 + (15 * i), ds_list_find_value(inventory, i));
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
