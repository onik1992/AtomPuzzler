<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_boy1</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-30</depth>
  <persistent>-1</persistent>
  <parentName>par_pausable</parentName>
  <maskName>spr_playertest</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize Player Variables
name = "Atom";

// Physics Variables
grav = 0.2;
hspd = 0;
hspd_platform = 0;
vspd_platform = 0;
vspd = 0;
jspd = 6;
mspd = 3;
mvmt = 0;

// Sprite Variables
spr = "boy1"
spr_run = spr_boy1;
spr_jump = spr_boy1_jump;
spr_fall = spr_boy1_fall;
image_speed = 0;
idle = false;
kicking = false;
idle_count = 0;

// Mechanic Variables
total_charge = 0;
global.inventory = ds_list_create();
is_winning = false;
complete = false;
paused = false;
scrn = -1;
global.attempts = 0;
toggle = 0;

//Atom placement when droping
atomX = 50;
atomY = 10;

// mobile input
if(mobile)
{
    input = global.input;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize Transition Variables
kind = transition.stripe_ver;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Play Music

// This will play the audio and set its priorty level to be higher than all other sounds
// because the player is persistant, the audio will continue to play.

if(!audio_is_playing(music_AtomPuzzlerTheme))
{
    audio_play_sound(music_AtomPuzzlerTheme, 1, true);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>other</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Sprite Operations

/* The player's sprite will turn left and right
depending on whether or not 'mvmt' is -1 or 1.
If the player is on the ground and moving, its 
sprite_index will be set to his running animation
(spr_boy1). If not, the player's sprite will be the 
first frame of his running animation, standing still
(frame 1 of spr_boy1). If the player is not on the ground,
and their 'vspd' is less than 0 (jumping) then the
player's sprite_index is set to 'spr_boy1_jump'.
Otherwise, the player's sprite will be set to the
'spr_boy1_fall' animation. Then, if the sprite_index is 
one less than its image_number, then the image_speed becomes
zero so the fall animation doesn't repeat.
*/


if(mvmt != 0)
{
    image_xscale = mvmt;
    
    if(mvmt == 1) facing_forward = true;
    if(mvmt == -1) facing_forward = false;
}
if(place_meeting(x, y + 1, obj_obstacle))
{
    if(mvmt != 0)
    {
        sprite_index = spr_run;
        image_speed = 0.2;
        idle_count = 0;
        idle = false;
        kicking = false;
    }
    else
    {
        if(idle)
        {
            sprite_index = spr_idle;
            image_speed = 0.2;
            
            if((image_index &gt; 7 &amp;&amp; image_index &lt; 8) || kicking)
            {
                if(spr_idle == spr_boy1_idle)
                {
                    image_speed = 0.15;
                }
                else if(spr_idle == spr_girl1_idle)
                {
                    image_speed = 0.14;
                }
            }
        }
        else
        {
            idle_count++;
            sprite_index = spr_run;
            image_speed = 0;
            image_index = 0;
            if(idle_count == 600)
            {
                idle = true;
            }
        }
    }
}
else
{

    if(vspd &lt;= 0)
    {
        sprite_index = spr_jump;
        image_speed = 0;
    }
    else
    {
        idle_count = 0;
        idle = false;
        kicking = false;
        sprite_index = spr_fall;
        if(image_index &lt; image_number - 2)
        {
            image_speed = 0.2;
        }
        else
        {
            image_speed = 0;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Change Character

// Checks Case for Character
switch(spr)
{
   case "boy1":
   {
       spr_run = spr_boy1;
       spr_jump = spr_boy1_jump;
       spr_fall = spr_boy1_fall;
       spr_idle = spr_boy1_idle;
       break;
   }
   case "girl1":
   {
       spr_run = spr_girl1;
       spr_jump = spr_girl1_jump;
       spr_fall = spr_girl1_fall;
       spr_idle = spr_girl1_idle
       break;
   }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Player Inputs and Physics Calculations (Keyboard)

/* 'key_right', 'key_left' and 'key_jump' are all variable 
place holders for the player's inputs. When the player presses
left or right, the 'keyboard_check's for left and right will 
either equal 1 or 0, making 'key_right' always equal 1 or 0 and
'key_left' always equal -1 or 0. 'keyboard_check_pressed' will 
check to see if 'vk_space' was only just pressed.
REMEMBER: these checks happen every frame of the game.
*/

if(toggle == 0)
{
    key_right = keyboard_check(vk_right) || keyboard_check(ord('D'));
    key_left = keyboard_check(vk_left) || keyboard_check(ord('A'));
    key_jump = keyboard_check_pressed(vk_space);
    key_left *= -1;
}

/* If key_jump is true, then the sound effect for jumping will be played.
*/

if ((key_jump == true &amp;&amp; jump) &amp;&amp; vspd == 0) 
{
    audio_play_sound(sfx_jump, 0, false);
}


// Use Player Inputs

/* 'mvmt' will be used as the number to represent whether or not 
the player wants to go left, right or nowhere -1, 0 or 1). 'hspd' 
will be the product of our 'mvmt' and our generic 'mspd' multiplier.
The first 'if' statement provided stops the player from gaining 'vspd' 
if their current 'vspd' is greater than or equal to 10 pixels per 
frame in the downward direction. Otherwise, it will continue to add 
'grav' to 'vspd' to make a new 'vspd' value. The second 'if' statement
ehecks to see if the player is on an 'obj_obstacle' object and sets the
'vspd' to the product of 'key_jump' (0 or 1) and the negative value of 
'jspd'. This will make the player's vspd negative, sending them 
upwards. 
*/

mvmt = key_left + key_right;

if(vspd &lt; 10)
{
    vspd += grav;
}

if(key_jump &amp;&amp; jump &amp;&amp; place_meeting(x, y + 1, obj_obstacle))
{
    vspd = -jspd;
}

// Pixel Perfect Horizontal Collisions

/* The 'if' statement checks to see if the player is a certain 
distance (x + hspd) away from the nearest 'obj_obstacle' horizontally. 
If they are, it checks to see if they are another distance away from
the 'obj_obstacle' (x + sign(hspd) and if they are, it adds the player's
absolute value of their 'hspd' to their current x-coordinate and makes
that value their new x-coordinate. Then, it sets the new 'hspd' to 0
to set the player's collisions and movement up for the next frame.
It then updates the player's new x-coordinate to their current x-coordinate
plus their 'hspd'. This ensures we get as close to the obstacle as possible,
without going into the obstacle. 
*/

var hspd_final = hspd + hspd_platform;
hspd_platform = 0;
if(place_meeting(x + hspd_final, y, obj_obstacle))
{
    while(!place_meeting(x + sign(hspd_final), y, obj_obstacle))
    {
        x += sign(hspd_final);
    }
    hspd = 0;
    hspd_final = 0;
}
x += hspd_final;

// Pixel Perfect Vertical Collisions

/* The 'if' statement checks to see if the player is a certain 
distance (y + vspd) away from the nearest 'obj_obstacle' vertically. 
If they are, it checks to see if they are another distance away from
the 'obj_obstacle' (y + sign(vspd) and if they are, it adds the player's
absolute value of their 'vspd' to their current y-coordinate and makes
that value their new y-coordinate. Then, it sets the new 'vspd' to 0
to set the player's collisions and movement up for the next frame.
It then updates the player's new y-coordinate to their current y-coordinate
plus their 'vspd'. This ensures we get as close to the obstacle as possible,
without going into the obstacle.
*/

/*var vspd_final = vspd + vspd_platform;
vspd_platform = 0;*/
var vspd_final = vspd;
if(place_meeting(x, y + vspd_final, obj_obstacle))
{
    while(!place_meeting(x, y + sign(vspd_final), obj_obstacle))
    {
        y += sign(vspd_final);
    }
    if(sign(vspd_final) == 1)
    {
        jump = 1
    }
    else
    {
        jump = 0;
    }
    vspd = 0;
    vspd_final = 0;
}
/*if(place_meeting(x, y + sign(vspd_final), obj_movingPlatform))
{
    vspd_final = 0;
}*/
y += vspd_final;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Prevents player from running forever and halts sprite animation
/*
    Whenever the player holds down right/left key and presses up near door, 
    player keeps running right and this fixes it
*/

if(toggle != 0)
{
    mvmt = 0;
    hspd = 0;
}

hspd = mvmt * mspd;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///mobile operations

if( mobile &amp;&amp; !instance_exists(obj_dialogue)){

    //swipe operation
    if (input.swipe &amp;&amp; input.swipe_spd &gt; 20)
    {
    
        switch ( scr_mobileControl(floor(input.swipe_dir )))
        {
            case 1: // right
                break;
            case 2: // up
                if(jump &amp;&amp; place_meeting(x, y + 1, obj_obstacle))
                {
                    vspd = -jspd - .5;
                    audio_play_sound(sfx_jump, 0, false);
                }
                break
            case 3: // left

                break;
            case 4: // down: Drop atoms
                    keyboard_key_press(ord('X'));
                    keyboard_key_release(ord('X'));

                break; 
        }
    }
    
    if (input.joy_active)
    {   //show_debug_message(floor((((radtodeg(input.joy_dir)+ 45)mod 360 )/90)));
        //show_debug_message(floor(radtodeg(input.joy_dir)));
        switch ( scr_mobileControl(floor(radtodeg(input.joy_dir))))
        {
            case 1: // right
                mvmt = 1;
                hspd = mvmt * mspd
                break;
            case 2: // up

                break;
            case 3: // left
                mvmt = -1;
                hspd = mvmt * mspd;
                break;
            case 4: // down
                break;
                
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///On Key Press X, drops previous atom picked

//  Notes: Deleting from ds_list does not change list size.
//  TODO: Remove last item from list, clear list, put leftover items into list again, this will require two lists maybe

atomDrop = keyboard_check_pressed(ord('X')) || keyboard_check_pressed(ord('M'));

if(atomDrop)
{

    if(ds_list_size(global.inventory) &gt; 0) 
    {
        obj = scr_drop_atom(global.inventory);
        //move the atom 
        if((instance_nearest(obj_player.x + atomX, obj_player.y - atomY, obj_atom1)
            &amp;&amp;  instance_position(obj_player.x + atomX, obj_player.y - atomY, obj_atom1))
            || (instance_nearest(obj_player.x - atomX, obj_player.y - atomY, obj_atom1)
            &amp;&amp;  instance_position(obj_player.x - atomX, obj_player.y - atomY, obj_atom1)))
        {
            atomX += 25;
        }
    
        else
        {
            atomX = 50;
        }

        if(!facing_forward)
        {   
            instance_create(obj_player.x - atomX, obj_player.y - atomY, obj);
            
        }
        if(facing_forward)
        {
            instance_create(obj_player.x + atomX, obj_player.y - atomY, obj);
        }
                            
        global.points -= 200;
        if(global.points &lt; 0)
        {
            global.points = 0;
        }
        
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Restart Room
/*
Checks if player has both collected the right atoms 
and checks if the inventory size is not 0
*/
if(mobile &amp;&amp; !(room == rm_initialize 
            || room == rm_splashScreen 
            || room == rm_mainMenu 
            || room == rm_scoreBoard 
            || room == rm_option
            || room == rm_difficulty))
{
    with(obj_mobileReset)
    {
        sprite_index = spr_mobileReset;
        image_xscale = .75;
        image_yscale = .75;
    }
}
else
{
    with(obj_mobileReset)
    {
        sprite_index = -1;
        image_xscale = .75;
        image_yscale = .75;
    }
}

//when the mouse clicks, it will emulate as if the player press the key "R"
if ( (mouse_check_button_pressed( mb_left )) &amp;&amp; mobile)
{
    if(mouse_check_button_pressed( mb_left ) &amp;&amp; instance_exists(obj_gameover))
    {
        keyboard_key_press(ord('R'));
    }
    with ( instance_position( mouse_x, mouse_y, obj_mobileReset))
    {
        keyboard_key_press(ord('R'));
        
    } 
    //show_debug_message("Reset");
    keyboard_key_release(ord('R'));     
}

if(keyboard_check_pressed(ord('R'))) 
{   
    if(!obj_player.is_winning || (ds_list_size(global.inventory) != 0) &amp;&amp; global.room_type == 1)
    {   
        obj_player.x = 32;
        obj_player.y = 415;
        toggle = 0;
        global.points = 0;
        ds_list_clear(global.inventory);
        room_restart();
        obj_player.attempts = 0;
    }
    
    if(!obj_player.is_winning || (ds_list_size(global.inventory) != 0) &amp;&amp; global.room_type == -1)
    {
        obj_player.x = 32;
        obj_player.y = 300;
        toggle = 0;
        global.points = 0;
        ds_list_clear(global.inventory);
        room_restart();
        obj_player.attempts = 0;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Press Spacebar after winning to continue

//when the mouse click it will emulate as if the player press the key "Space"
if ( mouse_check_button_pressed( mb_left ) &amp;&amp; instance_exists(obj_win) &amp;&amp; mobile)
{
    keyboard_key_press(vk_space);
    show_debug_message("enter door");
    keyboard_key_release(vk_space);     
}


if(is_winning &amp;&amp; keyboard_check_pressed(vk_space))
{
    ds_list_clear(global.inventory);
    global.points = 0;
    global.roomPoints = 0;
    toggle = 0;
    is_winning = false;
    global.attempts = 0;
    
    var next_room = ds_list_find_value(global.room_pool, global.room_pool_index);
    
    //Check if the next_room is the last index in room pool
    if(next_room = ds_list_find_value(global.room_pool, ds_list_size(global.room_pool)))
    {
        //stores the player name 
        name = get_string("Please enter your name:","");
        
        //puts score in to the score board
        highscore_add(name, global.totalPoints);
        
        //puts the player back to the main room
        room_goto(rm_scoreBoard);
        x = 32;
        y = 320;
        
        //reset the room pool index, incase the player wants to play
        //again goes back to room index 0 in the global.room_pool
        global.room_pool_index = 0;
        
    }
    else 
    {
        //room_goto(next_room);
        room_goto_transition(next_room, kind, 60);
        global.room_pool_index++;
        x = 32;
        y = 320;
    }
    
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_door">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///checks for mouse click and virtualize the press and release of the up key

if(mobile)
{
    if(mouse_check_button_released(mb_left) &amp;&amp; input.tap )
    {
        keyboard_key_press(vk_up);
        with(obj_door)
        {
            keyboard_key_release(vk_up);
            //show_debug_message("enter door");
        }
        
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Door Collision Event for Room Type Normal
/*
Checks for both lists: room and player's inventory.
Checks sizes of both lists, then checks for the content within list.
If the content within the player's inventory matches the room's list, then give correct feedback and move to next room and vice versa.
*/
doorPass = (keyboard_check_released(vk_up) || keyboard_check_released(ord('W')))

if(doorPass &amp;&amp; instance_nearest(x, y, obj_door).doorExit &amp;&amp; global.room_type == 1) 
{

    scr_debug_list();
    
    scr_sort_list(global.inventory);
    scr_sort_list(global.room_list);

    //Set variables for size of lists
    room_array_size = ds_list_size(global.room_list);
    inventory_size = ds_list_size(global.inventory);
    
    //Boolean set to false by default
    inventory_check = false;
    
    //Compare size of both lists
    if(room_array_size == inventory_size) 
    {
        //Compare and match list by index, if content doesn't match then break loop
        for(i = 0; i &lt; inventory_size; i++) 
        {
            if(ds_list_find_value(global.inventory, i) = ds_list_find_value(global.room_list, i))
            {
                inventory_check = true;
            }
            else
            {
                inventory_check = false;
                break;
            }            
        }
        
        //Win
        if(inventory_check)
        {
            is_winning = true;
            instance_create(0, 0, obj_win);
            //play level complete sound.
            audio_play_sound(sfx_next_Level, 1, false);
            //show_debug_message("obj_player: Event Collide: obj_door:  instance_create: obj_win");
            global.totalPoints = global.points - round(global.roomPoints) + global.totalPoints;
            obj_timer.stop = true;
            with(instance_nearest(x, y, obj_door)) doorExit = false;
            toggle = -1;
        }
        
        //Lose
        else
        {   
            is_winning = false;
            instance_create(0, 0, obj_gameover);
            //play level failed sound.
            audio_play_sound(sfx_F_Alarm, 1, false);
            //show_debug_message("obj_player: Event Collide: obj_door: On Lose: instance_create: obj_gameover");
            obj_timer.stop = true;
            toggle = -1;
            global.attempts++;
        }
    }
    
    //Size does not match therefore lose
    else
    {
        is_winning = false;
        instance_create(0, 0, obj_gameover);
        //show_debug_message("obj_player: Event Collide: obj_door: Incorrect List Size: instance_create: obj_gameover");
        obj_timer.stop = true;
        toggle = -1;
        global.attempts++;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Door Collision Event for Room Type Lab

/*
The reason why there is duplicate code for separate room types is that Lab rooms do
not have a timer object and Normal rooms do. The game throws an 'object that does not exist'
error if timer is stopped in Lab room, therefore the duplicated code for both room types.
*/
doorPass = (keyboard_check_released(vk_up) || keyboard_check_released(ord('W')))
if(doorPass &amp;&amp; instance_nearest(x, y, obj_door).doorExit &amp;&amp; global.room_type == -1)
{

    scr_debug_list();
    
    scr_sort_list(global.inventory);
    scr_sort_list(global.room_list);

    //Set variables for size of lists
    room_array_size = ds_list_size(global.room_list);
    inventory_size = ds_list_size(global.inventory);
    
    //Boolean set to false by default
    inventory_check = false;
    
    //Compare size of both lists
    if(room_array_size == inventory_size)
    {
        //Compare and match list by index, if content doesn't match then break loop
        for(i = 0; i &lt; inventory_size; i++)
        {
            if(ds_list_find_value(global.inventory, i) = ds_list_find_value(global.room_list, i))
            {
                inventory_check = true;
            }
            else
            {
                inventory_check = false;
                break;
            }            
        }
        
        //Win
        if(inventory_check)
        {
            is_winning = true;
            instance_create(0, 0, obj_win);
            //play level complete sound.
            audio_play_sound(sfx_next_Level, 1, false);
            global.totalPoints = global.totalPoints + 100;
            with(instance_nearest(x, y, obj_door)) doorExit = false;
            toggle = -1;
        }
        
        //Lose
        else
        {   
            is_winning = false;
            instance_create(0, 0, obj_gameover);
            //play level failed sound.
            audio_play_sound(sfx_F_Alarm, 1, false);
            //global.points -= 100;
            global.totalPoints = global.totalPoints - 100;
            toggle = -1;
            global.attempts++;
        }
    }
    
    //Size does not match therefore lose
    else
    {
        is_winning = false;
        instance_create(0, 0, obj_gameover);
        //global.points -= 100;
        global.totalPoints = global.totalPoints - 100;
        toggle = -1;
        global.attempts++;
    }
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Sorts list on door collide
scr_sort_list(global.inventory);
scr_sort_list(global.room_list);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_atom1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Adds Values from Received Atom

    total_charge += instance_nearest(x, y, obj_atom1).charge;
    ds_list_add(global.inventory, instance_nearest(x, y, obj_atom1).symbol);
    show_debug_message("Add to Inventory: " + string(instance_nearest(x, y, obj_atom1).symbol));
    complete = false;
    
    for(i = 0; i &lt; ds_list_size(global.room_list); i++)
    {
        if(instance_nearest(x, y, obj_atom1).symbol == ds_list_find_value(global.room_list, i))
        {
            //global.points += 200;
            complete = true;
        }
        if(complete)
        {
            break;
        }
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// add points
global.points += 200;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="7">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Sprite Operations

if(idle)
{
    if(kicking)
    {
        image_index = 8;
    }
    else
    {
        image_index = 8;
        kicking = true;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Wrap the Room for Player

move_wrap(true, false, rm1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw Self

draw_self();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
