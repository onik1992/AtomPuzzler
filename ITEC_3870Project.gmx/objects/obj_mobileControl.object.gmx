<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Source Code
/***************************************************************************************
*    Title: Touch Controls Object - Joystick/Swipes/Taps/Buttons
*    Author: Maximus
*    Date: 11/03/2016
*    Availability: https://forum.yoyogames.com/index.php?threads/touch-controls-object-joystick-swipes-taps-buttons.12521/
*
***************************************************************************************/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// initialize dpad, swipe, and tapping configuration
disp_w = display_get_width();
disp_h = display_get_height();

// joy input - left side of screen
// inputs
joy_x       = 0; // sqrt( joy_x^2 + joy_y^2 ) &lt;= 1
joy_y       = 0;
// settings
joy_region  = 0.5 * disp_w;
joy_range   = 100;
// process variables
joy_range_inverse = 1/joy_range;
joy_active  = false;
joy_device  = 0;
joy_dir     = 0;
joy_x_pos   = 0;
joy_y_pos   = 0;

// tap &amp; swipe inputs - right side of display or anywhere if joy is active
// inputs
tap             = false;
swipe           = false;
swipe_dir       = 0;
swipe_spd       = 0; // pixels per step
// settings
max_tap_time        = 30;
max_tap_distance    = 30;
// process variables
touch_active    = false;
touch_device    = 0;
touch_startx    = 0;
touch_starty    = 0;
touch_timer     = 0;


// initialize multitouch intputs
for (var i = 4; i &gt;= 0; i--)
{
    mouse[i]            = false;
    mouse_pressed[i]    = false;
    mouse_released[i]   = false;
    mouse_rx[i]         = 0; //mouse x rel to room
    mouse_ry[i]         = 0;
    mouse_gx[i]         = 0; //mouse x rel to gui
    mouse_gy[i]         = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// iterate through mouse devices for multi-touch input and collect input data
for (var i = 0; i &lt; 5; i++)
{
    //checks for first touch
   if device_mouse_check_button(i, mb_any)
    {
        // set mouse inputs
        mouse_pressed[i]    = !mouse[i];
        mouse[i]            = true;
        mouse_released[i]   = false;
        mouse_rx[i]         = device_mouse_x(i); // mouse x relative to room
        mouse_ry[i]         = device_mouse_y(i);
        mouse_gx[i]         = device_mouse_x_to_gui(i); // mouse x relative to gui
        mouse_gy[i]         = device_mouse_y_to_gui(i);
        //if (mouse_pressed[i]) {show_debug_message("mouse: " + string(i) + " pressed");}
        
        // check joy input
        if (!joy_active &amp;&amp; (mouse_pressed[i] &amp;&amp; (mouse_gx[i] &lt; joy_region)))
        {
            joy_active  = true
            joy_device  = i;
            joy_startx  = mouse_gx[i];
            joy_starty  = mouse_gy[i];
            joy_x_pos   = 0;
            joy_y_pos   = 0;
        }
        // check swipes and taps input
        else if (!touch_active &amp;&amp; !(joy_active &amp;&amp; (joy_device == i)))
        {
            touch_active = true;
            touch_device = i;
            touch_timer  = 0;
            touch_startx = mouse_gx[i];
            touch_starty = mouse_gy[i];
        }
    }
    else
    {
        mouse_released[i]   = mouse[i];
        mouse[i]            = false;
        mouse_pressed[i]    = false;
        //if (mouse_released[i]) {show_debug_message("mouse: " + string(i) + " released");}
    }
}

// get joystick input
if (joy_active)
{
    if (mouse[joy_device])
    {
        var distance;
        joy_dir     = degtorad(point_direction(joy_startx, joy_starty, mouse_gx[joy_device], mouse_gy[joy_device]));
        distance    = min(joy_range, point_distance(joy_startx, joy_starty, mouse_gx[joy_device], mouse_gy[joy_device]));
        joy_x_pos   = cos(joy_dir) * distance;
        joy_y_pos   = -sin(joy_dir) * distance;
        joy_x       = joy_range_inverse * joy_x_pos;
        joy_y       = -joy_range_inverse * joy_y_pos;
    }
    else
    {
        joy_x       = 0;
        joy_y       = 0;
        joy_x_pos   = 0;
        joy_y_pos   = 0;
        joy_active  = false;
    }
}
// get tap or swipe input
tap = false;
swipe = false;
if (touch_active)
{
    if (!mouse[touch_device])
    {
        var distance;
        distance = point_distance(touch_startx, touch_starty, mouse_gx[touch_device], mouse_gy[touch_device]);
        // check for tap
        if ((touch_timer &lt; max_tap_time) &amp;&amp; (distance &lt; max_tap_distance))
        {
            tap = true;
            //show_debug_message("tap detected - x: " + string(touch_startx) + ", y: " + string(touch_starty));
        }
        // check for swipe
        else 
        {
            swipe       = true;
            swipe_spd   = distance / touch_timer;
            swipe_dir   = point_direction(touch_startx, touch_starty, mouse_gx[touch_device], mouse_gy[touch_device]);
            //show_debug_message("swipe detected - speed: " + string(swipe_spd) + ", direction: " + string(swipe_dir));
        }
        touch_active = false;
    }
    touch_timer++;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// draw joystick
if (joy_active)
{
   draw_circle_colour(joy_startx, joy_starty, 10, c_gray, c_dkgray, false);
   draw_circle_colour(floor(joy_startx + joy_x_pos), floor(joy_starty + joy_y_pos), 10, c_silver, c_gray, false);
    //draw_sprite(spr_joy_base, 0, joy_startx, joy_starty);
    //draw_sprite(spr_joy_stick, 0, floor(joy_startx + joy_x_pos), floor(joy_starty + joy_y_pos));
}
// draw touch input
if (touch_active)
{
    draw_circle(mouse_gx[touch_device], mouse_gy[touch_device], 15, false);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
